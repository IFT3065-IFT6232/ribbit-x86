#!/usr/bin/chezscheme --program

;; @generated by Idris 0.5.1, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx tarm64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(let ()
(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define blodwen-toSignedInt
  (lambda (x bits)
    (if (logbit? bits x)
        (logor x (ash (- 1) bits))
        (logand x (- (ash 1 bits) 1)))))

(define blodwen-toUnsignedInt
  (lambda (x bits)
    (modulo x (ash 1 bits))))


(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (quotient x y) bits)))

(define b+ (lambda (x y bits) (remainder (+ x y) (ash 1 bits))))
(define b- (lambda (x y bits) (remainder (- x y) (ash 1 bits))))
(define b* (lambda (x y bits) (remainder (* x y) (ash 1 bits))))
(define b/ (lambda (x y bits) (remainder (exact-floor (/ x y)) (ash 1 bits))))

(define integer->bits8 (lambda (x) (modulo x (expt 2 8))))
(define integer->bits16 (lambda (x) (modulo x (expt 2 16))))
(define integer->bits32 (lambda (x) (modulo x (expt 2 32))))
(define integer->bits64 (lambda (x) (modulo x (expt 2 64))))

(define bits16->bits8 (lambda (x) (modulo x (expt 2 8))))
(define bits32->bits8 (lambda (x) (modulo x (expt 2 8))))
(define bits32->bits16 (lambda (x) (modulo x (expt 2 16))))
(define bits64->bits8 (lambda (x) (modulo x (expt 2 8))))
(define bits64->bits16 (lambda (x) (modulo x (expt 2 16))))
(define bits64->bits32 (lambda (x) (modulo x (expt 2 32))))

(define blodwen-bits-shl-signed (lambda (x y bits) (blodwen-toSignedInt (ash x y) bits)))

(define blodwen-bits-shl (lambda (x y bits) (remainder (ash x y) (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (cast-num (string->number (destroy-prefix x)))))

(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work)])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))


(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define System-prim__exit (lambda (farg-0 farg-1) ((foreign-procedure "exit" (int) void) farg-0) (vector 0 )))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0) (vector 0 )))
(define PreludeC-45IO-prim__putChar (lambda (farg-0 farg-1) ((foreign-procedure "putchar" (char) void) farg-0) (vector 0 )))
(define PreludeC-45IO-prim__getChar (lambda (farg-0) ((foreign-procedure "getchar" () char) )))
(define csegen-19(blodwen-lazy (lambda () (vector 0 (bs- (blodwen-toSignedInt 0 63) (blodwen-toSignedInt 999 63) 63)))))
(define csegen-38(blodwen-lazy (lambda () (cons (vector (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-422) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-422 eta-0)))))) (lambda (u--a) (lambda (arg-1124) (lambda (eta-0) arg-1124))) (lambda (u--b) (lambda (u--a) (lambda (arg-1130) (lambda (arg-1137) (lambda (eta-0) (let ((act-17 (arg-1130 eta-0))) (let ((act-16 (arg-1137 eta-0))) (act-17 act-16))))))))) (lambda (u--b) (lambda (u--a) (lambda (arg-1605) (lambda (arg-1608) (lambda (eta-0) (let ((act-24 (arg-1605 eta-0))) ((arg-1608 act-24) eta-0))))))) (lambda (u--a) (lambda (arg-1619) (lambda (eta-0) (let ((act-51 (arg-1619 eta-0))) (act-51 eta-0)))))) (lambda (u--a) (lambda (arg-10778) arg-10778))))))
(define csegen-39(blodwen-lazy (lambda () (DataC-45IORef-newIORef (csegen-38) (blodwen-toSignedInt 0 63)))))
(define u--prim__add_Integer (lambda (arg-0 arg-1) (+ arg-0 arg-1)))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define u--prim__mul_Integer (lambda (arg-0 arg-1) (* arg-0 arg-1)))
(define Main-writeAndReturn (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (let ((u--x (cast-int-char e-0))) (PreludeC-45Interfaces-C-62C-62 (let ((e-1 (car arg-2))) e-1) (PreludeC-45IO-putChar arg-2 u--x) (lambda () (let ((e-1 (car arg-2))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) arg-1)))))))))(else (Main-error "this is bad :/" arg-2)))))
(define Main-unsafeIndex (lambda (arg-0 arg-1) (if (null? arg-0) -1 (let ((e-1 (car arg-0))) (let ((e-2 (cdr arg-0))) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-1 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) e-1) (else (Main-unsafeIndex e-2 (bs- arg-1 1 63))))))))))
(define Main-sym (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rListTail (let ((e-6 (vector-ref arg-1 5))) e-6) arg-2 arg-3)) (lambda (u--tail) (let ((e-7 (car arg-3))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCar u--tail arg-3)) (lambda (u--r) (Main-rCar u--tail arg-3)))))))))))
(define Main-setupGlobal (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-MakeRib (let ((e-7 (vector-ref arg-1 4))) e-7) (vector 0 0) (let ((e-6 (vector-ref arg-1 5))) e-6) (vector 0 1) arg-2)) (lambda (u--primitive0) (let ((u--symtbl (let ((e-6 (vector-ref arg-1 5))) e-6))) (let ((e-7 (car arg-2))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-setGlobal u--symtbl u--primitive0 arg-2)) (lambda (symtbl-0) (let ((e-12 (car arg-2))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-setGlobal symtbl-0 (let ((e-20 (vector-ref arg-1 1))) e-20) arg-2)) (lambda (symtbl-1) (let ((e-17 (car arg-2))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-setGlobal symtbl-1 (let ((e-0 (vector-ref arg-1 0))) e-0) arg-2)) (lambda (symtbl-2) (Main-setGlobal symtbl-2 (let ((e-24 (vector-ref arg-1 2))) e-24) arg-2))))))))))))))))))))
(define Main-setVar (lambda (arg-1 arg-2 arg-3 arg-4) (case (vector-ref arg-2 0) ((0) (let ((e-0 (vector-ref arg-2 1))) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rListTail arg-1 e-0 arg-4)) (lambda (u--stackTail) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCar u--stackTail arg-4)) (lambda (u--stackTailCar) (Main-setCar u--stackTailCar arg-3 arg-4)))))))))))(else (Main-setCar arg-2 arg-3 arg-4)))))
(define Main-setGlobal (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-1 arg-3)) (lambda (u--symCar) (PreludeC-45Interfaces-C-62C-62 (let ((e-7 (car arg-3))) e-7) (Main-setCar u--symCar arg-2 arg-3) (lambda () (Main-rCdr arg-1 arg-3)))))))))
(define Main-setCgr (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--ref) (let ((u--v (vector (let ((e-9 (vector-ref u--ref 0))) e-9) (let ((e-8 (vector-ref u--ref 1))) e-8) (let ((e-7 (vector-ref u--ref 2))) e-7) arg-2))) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (set-box! e-0 u--v)))))))))))(else (Main-error "Third argument of setcar is not a rib" arg-3)))))
(define Main-setCdr (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--ref) (let ((u--v (vector (let ((e-9 (vector-ref u--ref 0))) e-9) (let ((e-8 (vector-ref u--ref 1))) e-8) arg-2 (let ((e-6 (vector-ref u--ref 3))) e-6)))) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (set-box! e-0 u--v)))))))))))(else (Main-error "Second argument of setcar is not a rib" arg-3)))))
(define Main-setCar (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--ref) (let ((u--v (vector (let ((e-9 (vector-ref u--ref 0))) e-9) arg-2 (let ((e-7 (vector-ref u--ref 2))) e-7) (let ((e-6 (vector-ref u--ref 3))) e-6)))) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (set-box! e-0 u--v)))))))))))(else (Main-error "First argument of setcar is not a rib" arg-3)))))
(define Main-setAndReturn (lambda (arg-1 arg-2 arg-3 arg-4) (PreludeC-45Interfaces-C-62C-62 (let ((e-1 (car arg-4))) e-1) (((arg-1 arg-2) arg-3) arg-4) (lambda () (let ((e-1 (car arg-4))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) arg-3))))))))
(define Main-run (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-1 (car arg-5))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-2 arg-5)) (lambda (u--instr) (let ((e-7 (car arg-5))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-2 arg-5)) (lambda (u--opnd) (let ((e-12 (car arg-5))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCgr arg-2 arg-5)) (lambda (u--next) (let ((e-17 (car arg-5))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-rToInt u--instr arg-5)) (lambda (u--v) (case (vector-ref u--instr 0) ((0) (let ((e-0 (vector-ref u--instr 1))) (cond ((equal? e-0 0) (let ((e-22 (car arg-5))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-getVar arg-3 u--opnd arg-5)) (lambda (u--proc) (let ((e-27 (car arg-5))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCar u--proc arg-5)) (lambda (u--code) (let ((e-32 (car arg-5))) (let ((e-34 (vector-ref e-32 1))) ((((e-34 'erased) 'erased) (let ((e-37 (car arg-5))) (let ((e-40 (vector-ref e-37 0))) (let ((e-42 (vector-ref e-40 1))) ((e-42 'erased) (Main-rIsRib u--code)))))) (lambda (u--codeIsRib) (cond ((equal? u--codeIsRib 1) (let ((e-37 (car arg-5))) (let ((e-39 (vector-ref e-37 1))) ((((e-39 'erased) 'erased) (let ((e-42 (car arg-5))) (let ((e-45 (vector-ref e-42 0))) (let ((e-47 (vector-ref e-45 1))) ((e-47 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (Main-MakeRib (let ((e-50 (vector-ref arg-1 4))) e-50) eta-0 eta-1 eta-2 eta-3)))))))))) (lambda (u--ribCreator) (let ((e-42 (car arg-5))) (let ((e-44 (vector-ref e-42 1))) ((((e-44 'erased) 'erased) ((((u--ribCreator (vector 0 0)) u--proc) (vector 0 0)) arg-5)) (lambda (u--newCont) (let ((e-47 (car arg-5))) (let ((e-49 (vector-ref e-47 1))) ((((e-49 'erased) 'erased) (Main-rCar u--code arg-5)) (lambda (u--codeCar) (let ((e-52 (car arg-5))) (let ((e-54 (vector-ref e-52 1))) ((((e-54 'erased) 'erased) (Main-rToInt u--codeCar arg-5)) (lambda (u--codeCarInt) (Main-lmdaCall arg-1 u--code u--next u--codeCarInt u--newCont u--newCont arg-3 arg-4 arg-5)))))))))))))))))) (else (let ((e-37 (car arg-5))) (let ((e-39 (vector-ref e-37 1))) ((((e-39 'erased) 'erased) (Main-rToInt u--code arg-5)) (lambda (u--codeInt) (let ((e-42 (car arg-5))) (let ((e-44 (vector-ref e-42 1))) ((((e-44 'erased) 'erased) (Main-primitive arg-1 u--codeInt arg-3 arg-5)) (lambda (u--stack) (let ((e-47 (car arg-5))) (let ((e-49 (vector-ref e-47 1))) ((((e-49 'erased) 'erased) (let ((e-52 (car arg-5))) (let ((e-55 (vector-ref e-52 0))) (let ((e-57 (vector-ref e-55 1))) ((e-57 'erased) (Main-rIsRib u--next)))))) (lambda (u--nextIsRib) (let ((e-52 (car arg-5))) (let ((e-54 (vector-ref e-52 1))) ((((e-54 'erased) 'erased) (cond ((equal? u--nextIsRib 1) (let ((e-57 (car arg-5))) (let ((e-60 (vector-ref e-57 0))) (let ((e-62 (vector-ref e-60 1))) ((e-62 'erased) u--next))))) (else (let ((e-57 (car arg-5))) (let ((e-59 (vector-ref e-57 1))) ((((e-59 'erased) 'erased) (Main-getCont u--stack arg-5)) (lambda (u--cont) (let ((e-62 (car arg-5))) (let ((e-64 (vector-ref e-62 1))) ((((e-64 'erased) 'erased) (Main-rCar u--cont arg-5)) (lambda (u--contCar) (PreludeC-45Interfaces-C-62C-62 (let ((e-67 (car arg-5))) e-67) (Main-setCdr u--stack u--contCar arg-5) (lambda () (Main-rCgr u--cont arg-5)))))))))))))) (lambda (u--output) (Main-run arg-1 u--output u--stack (bs+ arg-4 1 63) arg-5)))))))))))))))))))))))))))))))) ((equal? e-0 1) (let ((e-22 (car arg-5))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-rCar arg-3 arg-5)) (lambda (u--stackCar) (let ((e-27 (car arg-5))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCdr arg-3 arg-5)) (lambda (u--stackCdr) (PreludeC-45Interfaces-C-62C-62 (let ((e-32 (car arg-5))) e-32) (Main-setVar arg-3 u--opnd u--stackCar arg-5) (lambda () (Main-run arg-1 u--next u--stackCdr (bs+ arg-4 1 63) arg-5)))))))))))) ((equal? e-0 2) (let ((e-22 (car arg-5))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-getVar arg-3 u--opnd arg-5)) (lambda (u--opndVar) (let ((e-27 (car arg-5))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCons arg-1 u--opndVar arg-3 arg-5)) (lambda (u--newStack) (Main-run arg-1 u--next u--newStack (bs+ arg-4 1 63) arg-5)))))))))) ((equal? e-0 3) (let ((e-22 (car arg-5))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-rCons arg-1 u--opnd arg-3 arg-5)) (lambda (u--newStack) (Main-run arg-1 u--next u--newStack (bs+ arg-4 1 63) arg-5)))))) ((equal? e-0 4) (let ((e-22 (car arg-5))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-rCar arg-3 arg-5)) (lambda (u--stackCar) (let ((e-27 (car arg-5))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCdr arg-3 arg-5)) (lambda (u--stackCdr) (let ((e-32 (car arg-5))) (let ((e-34 (vector-ref e-32 1))) ((((e-34 'erased) 'erased) (Main-C-61C-61 u--stackCar (let ((e-40 (vector-ref arg-1 1))) e-40) arg-5)) (lambda (u--isFalse) (cond ((equal? u--isFalse 1) (Main-run arg-1 u--next u--stackCdr (bs+ arg-4 1 63) arg-5)) (else (Main-run arg-1 u--opnd u--stackCdr (bs+ arg-4 1 63) arg-5)))))))))))))))) ((equal? e-0 5) (PreludeC-45IO-putStr arg-5 ""))(else (Main-error "Unknown instruction" arg-5)))))(else (Main-error "Unknown instruction" arg-5)))))))))))))))))))))
(define Main-rToInt (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-2))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) e-0))))))(else (Main-error "Cannot cast rib to int" arg-2)))))
(define Main-rStringToUninternedSymbol (lambda (arg-1 arg-2 arg-3) (Main-MakeRib (let ((e-4 (vector-ref arg-1 4))) e-4) (let ((e-1 (vector-ref arg-1 1))) e-1) arg-2 (vector 0 2) arg-3)))
(define Main-rListToString (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rLength arg-2 arg-3)) (lambda (u--l) (Main-MakeRib (let ((e-7 (vector-ref arg-1 4))) e-7) arg-2 (vector 0 u--l) (vector 0 3) arg-3)))))))
(define Main-rListTail (lambda (arg-1 arg-2 arg-3) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int 0 arg-2))) (cond ((equal? sc0 1) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCdr arg-1 arg-3)) (lambda (u--cdr) (Main-rListTail u--cdr (bs- arg-2 1 63) arg-3)))))) (else (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) arg-1)))))))))
(define Main-rLength (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rIsPair arg-1 arg-2)) (lambda (u--isPair) (cond ((equal? u--isPair 1) (let ((e-7 (car arg-2))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-1 arg-2)) (lambda (u--cdr) (let ((e-12 (car arg-2))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rLength u--cdr arg-2)) (lambda (u--l) (let ((e-17 (car arg-2))) (let ((e-20 (vector-ref e-17 0))) (let ((e-22 (vector-ref e-20 1))) ((e-22 'erased) (bs+ (blodwen-toSignedInt 1 63) u--l 63)))))))))))))) (else (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (blodwen-toSignedInt 0 63)))))))))))))
(define Main-rIsRib (lambda (arg-0) (case (vector-ref arg-0 0) ((1) 1) (else 0))))
(define Main-rIsPair (lambda (ext-0 ext-1) (Main-rIsInstance 0 ext-0 ext-1)))
(define Main-rIsInstance (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-2 0) ((1) (let ((e-0 (vector-ref arg-2 1))) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-3))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--rib) (let ((e-7 (car arg-3))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rToInt (let ((e-11 (vector-ref u--rib 3))) e-11) arg-3)) (lambda (u--val) (let ((e-12 (car arg-3))) (let ((e-15 (vector-ref e-12 0))) (let ((e-17 (vector-ref e-15 1))) ((e-17 'erased) (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--val arg-1)))))))))))))))(else (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) 0))))))))
(define Main-rEqv (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-C-61C-61 arg-2 arg-3 arg-4)) (lambda (u--isTrue) (cond ((equal? u--isTrue 1) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (let ((e-0 (vector-ref arg-1 0))) e-0)))))) (else (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (let ((e-18 (vector-ref arg-1 1))) e-18)))))))))))))
(define Main-rCons (lambda (arg-1 arg-2 arg-3 arg-4) (Main-MakeRib (let ((e-4 (vector-ref arg-1 4))) e-4) arg-2 arg-3 (vector 0 0) arg-4)))
(define Main-rCgr (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--v) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (let ((e-14 (vector-ref u--v 3))) e-14)))))))))))(else (Main-error "Cannot cgr on number" arg-2)))))
(define Main-rCdr (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--v) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (let ((e-15 (vector-ref u--v 2))) e-15)))))))))))(else (Main-error "Cannot cdr on number" arg-2)))))
(define Main-rCar (lambda (arg-1 arg-2) (case (vector-ref arg-1 0) ((1) (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (unbox e-0))))) (lambda (u--v) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (let ((e-16 (vector-ref u--v 1))) e-16)))))))))))(else (Main-error "Cannot car on number" arg-2)))))
(define Main-primitive (lambda (arg-1 arg-2 arg-3 arg-4) (cond ((equal? arg-2 0) (let ((u--globalCounter (let ((e-4 (vector-ref arg-1 4))) e-4))) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (Main-MakeRib u--globalCounter eta-0 eta-1 eta-2 eta-3)))))))))) (lambda (u--ribCreator) (Main-prim3 arg-1 u--ribCreator arg-3 arg-4))))))) ((equal? arg-2 1) (let ((e-1 (car arg-4))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) arg-3))))) ((equal? arg-2 2) (Main-rCdr arg-3 arg-4)) ((equal? arg-2 3) (Main-prim2 arg-1 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-arg2 eta-0 eta-1 eta-2)))) arg-3 arg-4)) ((equal? arg-2 4) (Main-close arg-1 arg-3 arg-4)) ((equal? arg-2 5) (Main-prim1Pure arg-1 (lambda (u--x) (let ((sc1 (Main-rIsRib u--x))) (cond ((equal? sc1 1) (let ((e-0 (vector-ref arg-1 0))) e-0)) (else (let ((e-1 (vector-ref arg-1 1))) e-1))))) arg-3 arg-4)) ((equal? arg-2 6) (Main-prim1 arg-1 (lambda (eta-0) (lambda (eta-1) (Main-rCar eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 7) (Main-prim1 arg-1 (lambda (eta-0) (lambda (eta-1) (Main-rCdr eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 8) (Main-prim1 arg-1 (lambda (eta-0) (lambda (eta-1) (Main-rCgr eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 9) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-setAndReturn (lambda (eta-3) (lambda (eta-4) (lambda (eta-5) (Main-setCar eta-3 eta-4 eta-5)))) eta-0 eta-1 eta-2))))))))) (lambda (u--foo) (Main-prim2 arg-1 u--foo arg-3 arg-4)))))) ((equal? arg-2 10) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-setAndReturn (lambda (eta-3) (lambda (eta-4) (lambda (eta-5) (Main-setCdr eta-3 eta-4 eta-5)))) eta-0 eta-1 eta-2))))))))) (lambda (u--foo) (Main-prim2 arg-1 u--foo arg-3 arg-4)))))) ((equal? arg-2 11) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-setAndReturn (lambda (eta-3) (lambda (eta-4) (lambda (eta-5) (Main-setCgr eta-3 eta-4 eta-5)))) eta-0 eta-1 eta-2))))))))) (lambda (u--foo) (Main-prim2 arg-1 u--foo arg-3 arg-4)))))) ((equal? arg-2 12) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-rEqv arg-1 eta-0 eta-1 eta-2))))))))) (lambda (u--foo) (Main-prim2 arg-1 u--foo arg-3 arg-4)))))) ((equal? arg-2 13) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-7 (car arg-4))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (Main-lessthan arg-1 eta-0 eta-1 eta-2))))))))) (lambda (u--foo) (Main-prim2 arg-1 u--foo arg-3 arg-4)))))) ((equal? arg-2 14) (Main-prim2Pure arg-1 (lambda (eta-0) (lambda (eta-1) (Main-opRInt (lambda (eta-2) (lambda (eta-3) (bs+ eta-2 eta-3 63))) eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 15) (Main-prim2Pure arg-1 (lambda (eta-0) (lambda (eta-1) (Main-opRInt (lambda (eta-2) (lambda (eta-3) (bs- eta-2 eta-3 63))) eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 16) (Main-prim2Pure arg-1 (lambda (eta-0) (lambda (eta-1) (Main-opRInt (lambda (eta-2) (lambda (eta-3) (bs* eta-2 eta-3 63))) eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 17) (Main-prim2Pure arg-1 (lambda (eta-0) (lambda (eta-1) (Main-opRInt (lambda (eta-2) (lambda (eta-3) (PreludeC-45Num-u--div_Integral_Int eta-2 eta-3))) eta-0 eta-1))) arg-3 arg-4)) ((equal? arg-2 18) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-4))) ((e-6 'erased) (lambda (eta-0) (unbox (let ((e-10 (vector-ref arg-1 3))) e-10)))))) (lambda (u--pos) (let ((sc2 (PreludeC-45EqOrd-u--C-60_Ord_Int u--pos 18867))) (cond ((equal? sc2 1) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-getByte (let ((e-13 (vector-ref arg-1 3))) e-13) arg-4)) (lambda (u--v) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--v (blodwen-toSignedInt 255 63)))) (cond ((equal? sc4 1) (Main-rCons arg-1 (vector 0 -1) arg-3 arg-4)) (else (Main-rCons arg-1 (vector 0 u--v) arg-3 arg-4))))))))) (else (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (PreludeC-45IO-getChar arg-4)) (lambda (u--x) (let ((u--v (cast-char-boundedInt u--x 63))) (let ((sc4 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--v (blodwen-toSignedInt 255 63)))) (cond ((equal? sc4 1) (Main-rCons arg-1 (vector 0 -1) arg-3 arg-4)) (else (Main-rCons arg-1 (vector 0 u--v) arg-3 arg-4))))))))))))))))) ((equal? arg-2 19) (Main-prim1 arg-1 (lambda (eta-0) (lambda (eta-1) (Main-writeAndReturn eta-0 eta-1))) arg-3 arg-4))(else (Main-error (string-append "Primitive #" (string-append (number->string arg-2) " is not yet implemented ")) arg-4)))))
(define Main-prim3 (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-3 arg-4)) (lambda (u--z) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-3 arg-4)) (lambda (u--stack) (let ((e-12 (car arg-4))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCar u--stack arg-4)) (lambda (u--y) (let ((e-17 (car arg-4))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-rCdr u--stack arg-4)) (lambda (stack-0) (let ((e-22 (car arg-4))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-rCar stack-0 arg-4)) (lambda (u--x) (let ((e-27 (car arg-4))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCdr stack-0 arg-4)) (lambda (stack-1) (let ((e-32 (car arg-4))) (let ((e-34 (vector-ref e-32 1))) ((((e-34 'erased) 'erased) ((((arg-2 u--x) u--y) u--z) arg-4)) (lambda (u--newVal) (Main-rCons arg-1 u--newVal stack-1 arg-4)))))))))))))))))))))))))))))))
(define Main-prim2Pure (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-3 arg-4)) (lambda (u--y) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-3 arg-4)) (lambda (u--stack) (let ((e-12 (car arg-4))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCar u--stack arg-4)) (lambda (u--x) (let ((e-17 (car arg-4))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-rCdr u--stack arg-4)) (lambda (stack-0) (let ((u--newVal ((arg-2 u--x) u--y))) (Main-rCons arg-1 u--newVal stack-0 arg-4))))))))))))))))))))
(define Main-prim2 (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-3 arg-4)) (lambda (u--y) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-3 arg-4)) (lambda (u--stack) (let ((e-12 (car arg-4))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCar u--stack arg-4)) (lambda (u--x) (let ((e-17 (car arg-4))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-rCdr u--stack arg-4)) (lambda (stack-0) (let ((e-22 (car arg-4))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (((arg-2 u--x) u--y) arg-4)) (lambda (u--newVal) (Main-rCons arg-1 u--newVal stack-0 arg-4)))))))))))))))))))))))
(define Main-prim1Pure (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-3 arg-4)) (lambda (u--x) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-3 arg-4)) (lambda (u--stack) (let ((u--newVal (arg-2 u--x))) (Main-rCons arg-1 u--newVal u--stack arg-4))))))))))))
(define Main-prim1 (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-3 arg-4)) (lambda (u--x) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-3 arg-4)) (lambda (u--stack) (let ((e-12 (car arg-4))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) ((arg-2 u--x) arg-4)) (lambda (u--newVal) (Main-rCons arg-1 u--newVal u--stack arg-4)))))))))))))))
(define Main-opRInt (lambda (arg-0 arg-1 arg-2) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (case (vector-ref arg-2 0) ((0) (let ((e-1 (vector-ref arg-2 1))) (vector 0 ((arg-0 e-0) e-1))))(else (csegen-19)))))(else (csegen-19)))))
(define Main-main (lambda (ext-0) (Main-decodeAndRun ext-0)))
(define Main-lmdaCall (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6 arg-7 arg-8 arg-9) (let ((u--isNextRib (Main-rIsRib arg-3))) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int 0 arg-4))) (cond ((equal? sc0 1) (let ((u--nextNargs (bs- arg-4 1 63))) (let ((e-1 (car arg-9))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-7 arg-9)) (lambda (u--stackCar) (let ((e-7 (car arg-9))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-7 arg-9)) (lambda (u--stackCdr) (let ((e-12 (car arg-9))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCons arg-1 u--stackCar arg-5 arg-9)) (lambda (u--superNewStack) (Main-lmdaCall arg-1 arg-2 arg-3 u--nextNargs u--superNewStack arg-6 u--stackCdr arg-8 arg-9))))))))))))))) (else (cond ((equal? u--isNextRib 1) (PreludeC-45Interfaces-C-62C-62 (let ((e-1 (car arg-9))) e-1) (Main-setCar arg-6 arg-7 arg-9) (lambda () (PreludeC-45Interfaces-C-62C-62 (let ((e-1 (car arg-9))) e-1) (Main-setCgr arg-6 arg-3 arg-9) (lambda () (let ((e-1 (car arg-9))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCgr arg-2 arg-9)) (lambda (u--codeCgr) (Main-run arg-1 u--codeCgr arg-5 (bs+ arg-8 1 63) arg-9)))))))))) (else (let ((e-1 (car arg-9))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getCont arg-7 arg-9)) (lambda (u--k) (let ((e-7 (car arg-9))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCar u--k arg-9)) (lambda (u--k0) (let ((e-12 (car arg-9))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCgr u--k arg-9)) (lambda (u--k2) (PreludeC-45Interfaces-C-62C-62 (let ((e-17 (car arg-9))) e-17) (Main-setCar arg-6 u--k0 arg-9) (lambda () (PreludeC-45Interfaces-C-62C-62 (let ((e-17 (car arg-9))) e-17) (Main-setCgr arg-6 u--k2 arg-9) (lambda () (let ((e-17 (car arg-9))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-rCgr arg-2 arg-9)) (lambda (u--codeCgr) (Main-run arg-1 u--codeCgr arg-5 (bs+ arg-8 1 63) arg-9)))))))))))))))))))))))))))))
(define Main-lessthan (lambda (arg-1 arg-2 arg-3 arg-4) (case (vector-ref arg-2 0) ((0) (let ((e-0 (vector-ref arg-2 1))) (case (vector-ref arg-3 0) ((0) (let ((e-1 (vector-ref arg-3 1))) (let ((sc2 (PreludeC-45EqOrd-u--C-60_Ord_Int e-0 e-1))) (cond ((equal? sc2 1) (let ((e-3 (car arg-4))) (let ((e-6 (vector-ref e-3 0))) (let ((e-8 (vector-ref e-6 1))) ((e-8 'erased) (let ((e-15 (vector-ref arg-1 0))) e-15)))))) (else (let ((e-3 (car arg-4))) (let ((e-6 (vector-ref e-3 0))) (let ((e-8 (vector-ref e-6 1))) ((e-8 'erased) (let ((e-14 (vector-ref arg-1 1))) e-14))))))))))(else (Main-error "Less than on ribs (non-numbers)" arg-4)))))(else (Main-error "Less than on ribs (non-numbers)" arg-4)))))
(define Main-ins(blodwen-lazy (lambda () (cons 20 (cons 30 (cons 0 (cons 10 (cons 11 (cons 4 '())))))))))
(define Main-getVar (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-2 0) ((0) (let ((e-0 (vector-ref arg-2 1))) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rListTail arg-1 e-0 arg-3)) (lambda (u--stackTail) (let ((e-7 (car arg-3))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCar u--stackTail arg-3)) (lambda (u--stackTailCar) (let ((e-12 (car arg-3))) (let ((e-15 (vector-ref e-12 0))) (let ((e-17 (vector-ref e-15 1))) ((e-17 'erased) u--stackTailCar))))))))))))))(else (Main-rCar arg-2 arg-3)))))
(define Main-getInt (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getByte arg-1 arg-2)) (lambda (u--x) (let ((x-0 (Main-getCode u--x))) (let ((u--y (bs* arg-3 46 63))) (let ((sc1 (PreludeC-45EqOrd-u--C-60_Ord_Int x-0 46))) (cond ((equal? sc1 1) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (bs+ u--y x-0 63)))))) (else (Main-getInt arg-1 arg-2 (bs+ u--y (bs- x-0 46 63) 63)))))))))))))
(define Main-getCont (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCgr arg-1 arg-2)) (lambda (u--stackCgr) (let ((e-7 (car arg-2))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-1 arg-2)) (lambda (u--stackCdr) (let ((sc2 (Main-rIsRib u--stackCgr))) (cond ((equal? sc2 1) (let ((e-12 (car arg-2))) (let ((e-15 (vector-ref e-12 0))) (let ((e-17 (vector-ref e-15 1))) ((e-17 'erased) arg-1))))) (else (Main-getCont u--stackCdr arg-2))))))))))))))
(define Main-getCode (lambda (arg-0) (let ((u--x (bs- arg-0 35 63))) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int u--x (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 1) 57) (else u--x))))))
(define Main-getByte (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getAndIncrement arg-1 arg-2)) (lambda (u--pos) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) (cast-char-boundedInt (string-ref "R8llac/pmuj,htgnel-rotcev,?=<gnirts,trats-tni-llac,raaaac,?=>rahc,raaadc,_,dna,?naeloob,$,!llif-rotcev,trats-tni-tsnoc,rdaadc,tes,trats-tni-teg,mcl,etouq,dnapxe-dnoc,xam,oludom,esle,trats-corp-tsnoc,radddc,dnoc,rts-ot-tuptuo-htiw,cc/llac,adbmal,rdaddc,rdadac,raadac,!tes-rotcev,trats-llac,tel,stropxe-xtc,?>rahc,rotaremun,?tsil,rddddc,roolf,trats-teg,yllamron-margorp-tixe,margorp-daer,ypoc-gnirts,enifed,yllamronba-margorp-tixe,gnirts-ekam,?evitagen,2/be,liat,gniliec,?=<rahc,trats-mys-teg,dnuor,elif-led,trats-mys-llac,trats-tni-tes,nim,rotanimoned,tropxe,trats-tes,trats-mys-pmuj,etacnurt,radaac,slobmys-denretninu,raddac,rdaaac,trats-mys-tsnoc,ro,trohs-mys-llac,reffub,rotcev-ekam,!tes-gnirts,qmem,fer-rav-labolg,raaddc,trats-tsnoc,rddadc,teg,*tel,tsnoc,nigeb,trats-mys-tes,!tes,edoc-tegrat-etirw,vne-erudecorp,trats-tni-pmuj,?=>gnirts,certel,trats-fi,radadc,!llif-gnirts,tibbir,dmc-llehs,lbtmys,!tes-rav-labolg,?<rahc,pool,rahc-etirw,?evitisop,?orez,rddaac,fer-rotcev,fi,sedoc>-gnirts,sfed-teser,tsil>-elbat,tros-tsil,enil-dmc,edoc-etareneg,?ddo,rahcteg,tpxe,noisnetxe-htap,?regetni,yrarbil-daer,dcg,elif-tupni-htiw-llac,lper,relipmoc-enilepip,htap-elbatucexe,elif-tpircs,ssenevil,sisylana-ssenevil,?=rahc,htgnel-elbat,gnirts-ot-tuptuo-htiw,dnibnu-neg,enil-daer,!tros-tsil,elif-morf-tupni-htiw,>,lobmys-denretninu>-gnirts,?qe,rebmun>-gnirts,margorp-elipmoc,vssa,?neve,?erudecorp,elipmoc,=<,lave,elif-ot-tuptuo-htiw,?>gnirts,redniamer,?<gnirts,!tes-evil-xtc,edocne,stropxe-tcartxe,xua-lobmys>-gnirts,tsil-dnapxe,xua-rebmun>-gnirts,xua-sisylana-ssenevil,stropxe-htiw-srpxe-pmoc,yrotcerid-htap,raadc,repo,rebmem,rahc>-regetni,xua-gnirtsbus,2xua-rebmun>-gnirts,xua-pmc-gnirts,radac,elbat-ekam,xua-rahc-daer,llac-neg,edoc-erudecorp,?=gnirts,xtc-ekam,*dnib-pmoc,?tnatsnoc,!tes-elbat,radc,gnirts>-lobmys,raaac,ngissa-neg,tnemmoc-piks,tsil-etirw,tsil-daer,?ni,tsila>-stropxe,llac-pmoc,rdaac,raac,xua-tsil-ekam,dnib-pmoc,rdadc,xua-esrever,raddc,xua-?tsil,evil>-stropxe,elif-morf-gnirts,liat-tsil,tixe,xua-dcg,evil-xtc,fer-tsil,lobmys>-gnirts,?2erudecorp,tnatsnoc-dnapxe,hcae-rof,lla-daer,poon-neg,ydob-dnapxe,lave-dnapxe-dnoc,pmc-gnirts,dnetxe,erudecorp-ekam,elif-morf-daer,!rac-tes,1tsil,xua-gnirts>-rebmun,lobmys-esu,3tsil,nigeb-dnapxe,rotcev>-tsil,2tsil,?rotcev,rdddc,tsil-ekam,sba,ecapsetihw-non-rahc-keep,!tes-tsil,regetni>-rahc,lobmys-daer,?gnirts,lobmys-denretninu>-rts,tsil>-rotcev,fer-elbat,gnirtsbus,tes-etc-xtc,cossa,!tes-2dleif,gnirts>-rebmun,enod-ydob-dnapxe,2rahctup,rdddac,?tcejbo-foe,?ecnatsni,daer,fer-gnirts,srahc-daer,etanetacnoc-gnirts,rts>-lobmys,rahc-keep,enilwen,pp,fi-dliub,?evil,sesualc-dnapxe-dnoc-dnapxe,*nigeb-dnapxe,!tes-1dleif,?llun,etirw,dnpo,etc-xtc,gnirts>-maerts,pukool,txen,qssa,!rdc-tes,tneitouq,evil-dda,srahc-etirw,?bir,nigeb-pmoc,=>,esrever,htgnel-gnirts,rorre,vmem,dneppa,=,gnirts>-tsil,rddac,xeh-daer,2dleif,?lobmys,tsil>-gnirts,!tes-0dleif,rahctup,*,htgnel,rpxe-dnapxe,hguorht-epip,ecalper-gnirts,setyb-ot-edoc-mvr,rid-toor,?lauqe,dnapxe-htap,rahc-daer,pam,1dleif,0dleif,yalpsid,rddc,pmoc,ton,<,+,-,rdac,dneppa-gnirts,?riap,esolc,rac,2gra,1gra,?vqe,rdc,snoc,di,lin,eurt,eslaf,bir;8U/!U/88YU9YTMYS9ki$i$kiY'y!V$8TFE88by^88_~UiY0^{!A7&i&kkC^[$E9>iX%Z%?aZKZ$h-_f7$IlfC^[$E7/fJldb7'Il^~YU*Z@`h1Z@J`dh/70??h.ZKh.gh3h4_^Jh/c~Kk^zi$~YTHZ$gJf_|i$Z$aZ$_|!@9>`RYH_E9GYS#^z{!U9'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBi$'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBOiWKBOZ$^BOiX(~Z&ldGiXC'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBi$'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBOiWKBOZ$^BOiX(~Z&ldGYSCe~e_YSCTVGGGdiX0biX:'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBi$'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBOiWKBOZ$^BOiX(~Z&ldGiXC'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBi$'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^LgCYAiXKiXDYAWiX;aWiY%_YAWiXLaWiWO_YAa_`iY-'^YB_TVGGiX,eiXI'^^~CUiX7e'^YB_TVGGiX,eiXI'^^~C^~^Lg^~UiXAcBOiWKBOZ$^BOiX(~Z&ldGYSCe~e_iY#~UiY)aYTA__@cDb}(!SC8U1E8U&i$^z^z!VN8OYS2`8OYS9~UiXB`YU3^{!U38S2^8S2TTViXJGiX.^~UiX8YU5^z!S28U$iS9^z!S9(YS9^'i&~ZC^ZAy!?8T:CYU.8T:C^~^YU-y!U>8;YH_iS#z]08MR_E8T6^8T6vD~YNvS#^JvF^zz!TA7&i&`kC^[$E7&ca_C^[$E7&cg_C^[$E7$aC^[$E0GGZ0aiY.Z>iX#RaE8MZ%YH^Z=^zZ0XBi&IYD`YDeX?i&hR%7'@^~i$0GGZ0aiY.Z>iX#RaE8MZ%YH^Z=^zZ0XBi&IYD`YDeX?i&hR%7'@^~YT-iX&Z=D^~F^zi$70?h-a@eJlcBYGd^@aZNiY17.e@ca~^Z-hR%^D^D_~F_|i$7.e@ca70?h-a@eJlcBYGd^@a@^~^Z-hM^D^D_~F_|i$70?h-`@eJlcBYGd`ZNiY(70?h-`@eJlcBYGd`@^~^Z-hH_@_D^D_~i$7&ca_C^[$E7&cg_C^[$E7$aC^[$E0GGZ0aiY.Z>iX#RaE8MZ%YH^Z=^zZ0XBi&IYD`YDeX?i&hR%7'@^~i$0GGZ0aiY.Z>iX#RaE8MZ%YH^Z=^zZ0XBi&IYD`YDeX?i&hR%7'@^~YT-iX&Z=D^~F^zi$70?h-a@eJlcBYGd^@aZNiY17.e@ca~^Z-hR%^D^D_~F_|i$7.e@ca70?h-a@eJlcBYGd^@a@^~^Z-hM^D^D_~F_|i$70?h-`@eJlcBYGd`ZNiY(70?h-`@eJlcBYGd`@^~^Z-hH_@_D^D_~KiV3^~F_|i$YU;YU<h<E4X)_X(_{BX5h<BX1h<BYS:iXOE74n^z[$E89^@`3YD_vS[rz0~^YT7iXO^D^z[%E9#i&iXG9#_iX?7+X,?ciUMZ2`Z._~AwU?^7+CZ#_iX>7+CX/c^~YS<^7+CX3dX4_iV5~YI^7+CX4d_iW>7+C?cJ_iV,~Kv.^~X-^Z2`Z._~AwV(^7+CZ#_iX57+CX3dX4_iVD~YI^7+CX4d_iW;7+C?cJ_iVP~Ku^~X-^Z2`Z._~AwV*^7+CZ#_iX*7+CX3dX4_iV&~YI^7+CX4d_iV@~X-^Z2`Z._~AwW<^7+CZ#_iWM7+CCX4e_iVA7+CC?dJ_iW*~KiV3^X3^~YI^7+CX4d_iWG~X-^Z2`Z._9#_iX'73d_iV;(cJ_k~Kv7^X2^~YI^73c_iUP~X,^Z2_~AZ.`k~AwWJ^YT8^~Z(^{[&E8U4^z['E7,X4d`JoiW47,?cJ`iW4~Ko_Z._P^YT.^{[(E72e_`'^~YNk`?bJiVH^72e_`'^~YNk`?b^~AcaIYEiVH__Z+iVH^|[)E7.a`^{[*E(``(@`Jl`~YNJliVH^D^X/a_|[+E(X0b`^|[,E89^ZLi$_h>z[-E'i$76n^~AwW<_77l^BZ5_aBYGwV*aX8^76m^~CCi$77l^BZ5_aBYGwV*aX8^76m^~CCZ&k`~X-`77l^BZ5_aBYGwV*aX8^76m^~CC^~^YS<_77l^BZ5_aBYGwV*aX8^76m^~C^~^YI^~AwV(_76l^~AwV*_76k^~AwWJ_73^~AwU?_Z2_YT8^z[.E'i$71Z.^BX0^~Z(^z[/E'i$75^~YS<^'i$9HJYJ`l^~YNm`95JQ`l^~YNl`8GJP`l^~YNk`CC^BYT)`ahA:kkk'i$9HJYJ`l^~YNm`95JQ`l^~YNl`8GJP`l^~YNk`C^~^ZLi$_h?~YI^{[0E'^BX4`^{[1E71Z.YT.^z[2E'^BX4k^z[3E'^BX6n^BX?_`[9Jlh8YS=GZGh8iX11^~^Z-h>^'w&~Ai&^'w%~Ai%^'w$~Ai$^z[4k[5E9HX=X;YJ_^P^z[6E7%`h>C^[$E'_7-XE:gbwW<_@bN`H_D^D^~F^{i$z[7E#X>bYJ`Q_P^'_~Ak^{[8E7%a@iX6C^[$E'_7)CCb7)CCX-c_~i$7)CCb7)CCX-c_~CCKYJak7)CCb7)CCX-c_~CC^~^KQ`k7)CCb7)CCX-c_~C^~^KP_k~^ZLi$_hFDD_@^~F^{i$[$E#::::h.XBngwW<X@kw#wWJlwV(kwV(HZ-iX6_wV({i$z[9E'`[@?h@??`a_X?k^{[:E9#_iX@7@XA::fX;kw#wWJowV(YD_^ZM^~YS)^7@XA::fX;kw#wWJnwV(YD_^RYH_iS#~ZO^7?X@::eX:kw#wWJkwV(@_D^~F^#a_wV(#::eX:kw2wWJIbkwV(kwV(~Kk^~X*^#aX6m_wV(~YI^#bX7l_wV*X7^~CZ-h@_9#_iX@7@XA::fX;kw#wWJowV(YD_^ZM^~YS)^7@XA::fX;kw#wWJnwV(YD_^RYH_iS#~ZO^7?X@::eX:kw#wWJkwV(@_D^~F^#a_wV(#::eX:kw2wWJIbkwV(kwV(~Kk^~X*^#aX6m_wV(~YI^#bX7l_wV*X7^~C^~^YPiXH^{[;i&[<YT1i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i$i${!UMJJloiW4!W4JmiV5!V5JliW>!W>Jv.iV,!V,JmiVD!VDJliW;!W;JuiVP!VPJmiV&!V&JliV@!V@JkiV<!V<JmiVA!VAJliWG!WGJiV3iW*!W*JmiV;!V;JliUP!UPJv7k!V3IJJJJv4v7uov.vS#!VHZ+mvS#!U,'cBX'i%i&b[$E'i$7)`@^BX+i$`D^~F^{[%E'i$7+a_7.i$YS4c_YL`H_~AwW/^7+a@_~AwV'^7.i$YOcR`i-YL`BX,bR_i1H_~AwW)^7-i$aZD_BX-i$aYL_BX-i$aH_~AwU?^'i$70i$d_BZ,?@``^~^Z8h1_Bi$'i$70i$d_BZ,?@``^~^Z8h1_BX/_~h17/i$c^~YSOc_YL`H_~AwV%^7-^H_~AwW9^D^~F^7,^'i$~YSO`^~YI^|[&E'i$8S:ZM_c~YS)^7)@^BX)D^~F^7*^~YI^z['E'k[,Z*g^zi$i$i$i$|!SO5AZ/ka_^{!T*'i$'i$'i$*DH_wW9~FH^~Z4N^~F@^z]8'i$98@a_'^~AD__D_~F_{]*(a^?i&^'_~Z8`^{!U=7$_C^[$E'i$7'@^BZ,i&D^~F^zi$z!SD'i&(YSD@_?i&DD^~F^z!T<7$Z*Z*Z*Z*YSDCi&7$Z*Z*Z*Z*YSDC^~^dw'w.w,w+C^[$E7(^'_~A`^YU,Le_bBYU=^zi${!U+'^8T<a_~ZI_wUHYT<i&^{!T>'i&(YT>@_YCD^~F^z]7'_97a@_96a@^~CYS6D_97a@_96a@^~C^~^AD_wW5D^~F^{!S6*wUJ^5LYPR@`iS6i%~i$*wUJ^5LYPR@`iS6i%~AwV4D^~F^5YPR@`iS6i$~i$*wUJ^5LYPR@`iS6i%~i$*wUJ^5LYPR@`iS6i%~AwV4D^~F^5YPR@`iS6i$~AwWBD^~F^5YS6H^~i$*wUJ^5LYPR@`iS6i%~i$*wUJ^5LYPR@`iS6i%~AwV4D^~F^5YPR@`iS6i$~i$*wUJ^5LYPR@`iS6i%~i$*wUJ^5LYPR@`iS6i%~AwV4D^~F^5YPR@`iS6i$~AwWBD^~F^5YS6H^~Aw5D^~F^z]6'_(_YC_97_@_~i$(_YC_97_@_~AwW8D_~F_96_@_~i$(_YC_97_@_~i$(_YC_97_@_~AwW8D_~F_96_@_~AwV'D_~F_Z6a@_D^~F^{!S,8S;k-^(_wV'~F@^~F^Z6i&^z]F8S,_8C??aZ%_wUN~F^{!S77%i&_C^[$E9FiXP_9F``7+?c?Na_@`7+?c??i&??Nc@awW/D_@`~F^H^~i$9F``7+?c?Na_@`7+?c??i&??Nc@awW/D_@`~F^H^~i$9F``7+?c?Na_@`7+?c??i&??Nc@awW/D_@`~F^H^~F@^~AD_wVL~F^D^~F^{i$z!S;(?i&_wW9z!C8S;^8T>_8Ci$8C????i&?NcwW2?@HbwV'DH`wU?8C?@H`wV'~ADH`wW5~F@_~AwW2^8Ci$8CH_8C???i&????i&?NewV4wWCwWCwU??i&??i&HawWCwW)~FN_~F@_~AwV4^8Ci%8CH_8C????i&i$?NbwWBH`wU?~FN_~F@_~AwWB^(??i&YCYLb_wV%(??i&YC??Nd@awW/D_wV%~F^H_~AwVL^8S,@_~AwV'^8C??YONcRaE(??i&H`D_wV%zR`E(?i&i$D^zwW)H_~AwUN^8C?@a8C???i&??Nd@awV)?i&D_~i$8C?@a8C???i&??Nd@awV)?i&D_~F@_~F_wW)H_~AwV)^8S7Na(??i&YS7NcR`E(?i&YCH_D^zwW)~F^^8CC?R`i1???i&a?i&??i&??YS(eRbi-wW/`wUNYL`~YI^H_~AwW)^(??i&YS7Nb_wW/H_~AwW/^(???i&i$(???i&YCZDb~FYS(bYCYLaYCH`wU?~AwU?^(??i&YCYLb_wV%H_~AwV%^8S;H_~AwW9^D^~F^'^~YI^z!TM'^Bi$'^BZ:@^BOiY+~Z&nbBi$'^Bi$'^BZ:@^BOiY+~Z&nbBZ:D^BOiY,~Z&mbYT;YSN_?i&i$'^Bi$'^BZ:@^BOiY+~Z&nbBi$'^Bi$'^BZ:@^BOiY+~Z&nbBZ:D^BOiY,~Z&mbYT;YSN__~F_@_D^YT@_BOiWN{!T;(CRaE(_^D^z(C^~^bYS3i&:MiVGbYT,Ci&(CRaE(_^D^z(C^~^bYS3i&:MiVGbYT,C^~^eai&kkBO_YU+a^YS,^BOiX+{!SN'^8;_E(H_D^(_^~YI^z~F^z!T@7&i$i&_C^[$E(aZ%_7,c?b_@_7,YOCi&7,YOC^~^d@`a@_~i$7,c?b_@_7,YOCi&7,YOC^~^d@`a@_~AwV=D^~F^D^~F^BOiX-|i$BOiWPz!VG:kw'wWJ!S4'_(YS4a@_D^~F^{]/'^9/Jlb@`^'`~A_D_~F_|!SM7&^6YSMd@bZJ?Z1bi$`D`^~F_|]'6b6:Z'f@dbYS.w+awWJ~F@aD`^|!S.'_BYTBZ*YS?``^{!U'#aYS.w,_wWJ'_~AiVG_{!T+9'eca6YT+YU'h2gh/ZJ?Z1h/eh-@f@dZJ?Z1di$b_`DaD_~F_})!SI8T+geab`^}(!S8#`kwV(8J^~i$#`kwV(8J^~i$#`kwV(8J^~i$#`kwV(8J^~Z(YJ^~Aw+Q^~AwWJP^~Z(^z!T%#YS8a_wW<{!T/#a_wWJ#k_wWJ~AiVG_{!6#b`wV(8SIf?i&?bwWC?i&aiX<`8SME8T/h.^Z/kZ1_dz_`~YI_@`8SIgaRbi1Rai-aNaH`~AwW)^9'c@a_~AwV'^#YT/eYS.w.b#d~Z4Z1bYS3i&:Z'iVGNeZJYS4??Z1gi$i$bckYD_wV(H`~AwW/^6`Hdb:a_wU?MdYLb`McZDa_~AwU?^6YT%g``b8S8e6YT%h-aac8S8e~YT*^~^Z8YS?c`~Aa^Z/lZ1b_YLaH`~AwV%^#cHawV(~AwW9^D_~F_#d`wV*#dHH_wV(~i$#d`wV*#dHH_wV(~YT*^~^Z8YS?``Z/kZ1__~YI_|!TB8S1`Q^{]J#YJ`Q__{!W(8J^z!S?-Q^z]189^z!T,#b?i&`^|].8J^z]28:^z!T889^z!S<iTJ]#'iX2BZ;BZ3_BZ;BO^{]>'iXM7%YHDa@`C^[$E8M_7)YOYObeYHD_@^~F^{i$YH`Z%^~F^{!U.'iXEy!U--YU:y!U;8U%YOi&`^{!U%7(_c'i&~YN_kYDb[$E'^BZ,b_'^BZ,a_7/f@dc`BZ,ca7/@fdd`BZ,da~X0`^DbD`~Fa~F`}'[%E'_'^7-d@ba`7-@dbba~X.`^D`D^~F_~F^{[&E7%a_C^[$E71_X2eeX1Ief_7)@`Il^~YU#k^{i$Z+m_'^BZ,i&^~YNl_{i$i$i${]:9;BZ3^z!U&7$i&C^[$E7(?`^8MZ%_~CAf_7(?`^8MZ%_~C^~^ZC^Sbzi${!=0G`iY*_0__~YNvR$YS#Z@IlZ$`_'^~YNkZ$_{!T:7$IlZ$_C^[$E7'Il^9KJl`kb~YNvR$YS#Z@_b'iY$~Kk^zi$z!U57$IlZ$_C^[$E7'Il^9KZ$d_b~YNvR#YS#Z@_b'iX)~Kk^zi$z]=9LYT'`_iV8z]N'^BYT)b_iV8YS=^GZGYU)iV8iWLz!V8YT1!U<-^z!U)8DD^z!T)8S1?Da?ca_9,b^~^ZID__|]L'a)^~^ZID__|!T1(i&i&y!W18U(^z!VK8SAly!VO8SAky!U:(i&iX/y!B'_BOiX9BO^BOiY/BOiX$BOiXN{!VB'i$z!UI'i$z]#8SAlBZ;BZ3_BOiY&BO^{!U08U0BZ;BZ3YTG^9;~ZC^ZABZEvCvR3y!TG7#YTI^z!TI.7&i&yM_i&z]/'^9/Jlb@`^'`~A_D_~F_|]''^.7'^BX(^zZ'@a_~F@`MD`^{!S0(i&^z!S*(YS0`^{!S-(YS*b`^|]9(YS-ca_wU?|!6.'bz9#diX=.7&X*aX*`X*_X,^zYLaH`D_~A_n.7%X)`X)_X+^zH`D_~A_m.7$X(_X*^zD_~A_l.7#X)^z~A_kYD^R@bE6_czM__6i$6Z9?NdwW2?@HcwV'DHa6?@HbwV'~ADHbwW5~F@a_~AwW2^6i$6C^6CYS-Z9?NgwV4wW@wW@YS0YS*`wW@wW)~FNbHa~F@a_~AwV4^6i%6C^6CZ9i$?NdwWB^~FNbHa~F@a_~AwWB^.7'?_X)^zZ'Nd^?bD_MH_`DH`~AwW)^9'@a_~AwV'^9#eiXF..7-???fb`^|z~A_n..7,??d`^{z~A_m..7+?b^zz~A_l..7*`yz~A_kYD`Z'Nc^YOa^H`~AwW/^.7'^7(^~X)^zMZDcaMYLb`MHa_~AwU?^.8S$X)`c^z.8GX(_bz~Z(_MYLb`Z/k`H`~CAwVL_9#diX=.7&X*aX*`X*_X,^zYLaH`D_~A_n.7%X)`X)_X+^zH`D_~A_m.7$X(_X*^zD_~A_l.7#X)^z~A_kYD^R@bE6_czM__6i$6Z9?NdwW2?@HcwV'DHa6?@HbwV'~ADHbwW5~F@a_~AwW2^6i$6C^6CYS-Z9?NgwV4wW@wW@YS0YS*`wW@wW)~FNbHa~F@a_~AwV4^6i%6C^6CZ9i$?NdwWB^~FNbHa~F@a_~AwWB^.7'?_X)^zZ'Nd^?bD_MH_`DH`~AwW)^9'@a_~AwV'^9#eiXF..7-???fb`^|z~A_n..7,??d`^{z~A_m..7+?b^zz~A_l..7*`yz~A_kYD`Z'Nc^YOa^H`~AwW/^.7'^7(^~X)^zMZDcaMYLb`MHa_~AwU?^.8S$X)`c^z.8GX(_bz~Z(_MYLb`Z/k`H`~C^~^AwV%^.'azH`~AwW9^D_~F_.8S>b^z'jD~An^'iL~Am^'i1~Al^'i-~Ak^.89az~Z(^Z/k__~YI_{]E8F_BYF^{];8Fuy!UDiF])'i$9)a@_BYF^9)a@_BYF^BYFvS#~CAvS#_9)a@_BYF^9)a@_BYF^BYFvS#~C^~^AvE^9)a@_BYFvS;BYFvS#~At^9)a@_BYFvS9BYFvS#~Av0^9)a@_BYFvS5BYFvS#~Au^9)a@_BYF^~L`D^~F^{!T#'i$'i$8T#@^BZ3D^~F^BYFvC~F^z!888ZG^9EvS7vF~YTJ^93ZM^BYFvF~YS)^9)i$YH^~ZO^88YT'^~YI^8FvLBYT#@^BZ3D^BYFvK~F^9EvLvK~Z4^9EvS;vF~Ai%^9EvS-vF~L^z]388^8FvEBZ)i%YH^BYFvE~ZO^z!T$8T$8S%~Au^'^~Kk^Sy!S%8S%BS'^8T$~AvR0^~K_vC'iX4~ZC^Z<y]?9??`^9??a^9??at~AvS;^9??av0~AvS9^9??au~AvS5^S~AvS#^9%_~AvE^'i&~ZC^Sz]P(ZP^BS'i&~CCKvD`(ZP^BS'i&~CC^~^AvL_(ZP^BS'i&~C^~^AvK^Z<y!SP(YSP^ZA'i&BS~AvL^YS%y!K'_8KIIvRL_YE`v3BS~i$'_8KIIvRL_YE`v3BS~KvS.^~K_vS'8KIIvR,_YE`v3BS~i$'_8KIIvRL_YE`v3BS~i$'_8KIIvRL_YE`v3BS~KvS.^~K_vS'8KIIvR,_YE`v3BS~KvR<^~K_vR58KIIvR%_YE`v3BS~i$'_8KIIvRL_YE`v3BS~i$'_8KIIvRL_YE`v3BS~KvS.^~K_vS'8KIIvR,_YE`v3BS~i$'_8KIIvRL_YE`v3BS~i$'_8KIIvRL_YE`v3BS~KvS.^~K_vS'8KIIvR,_YE`v3BS~KvR<^~K_vR58KIIvR%_YE`v3BS~KvR/^~K_vR$Z<z]A8S=`'^~^^YTN^YM?ZP^BS8MZ?i&BS~AvE^(?i&ZAwW9BS~AvJ^8S+ZA2YKkk8KkBS~AvP^Z<BS~CAvRM_8S+ZA2YKkk8KkBS~AvP^Z<BS~C^~^AvS?^'i%BS~AvS;^'i$BS~AvS-^Z<BS~AvF^8SPBS~AvK^'^~Kk^YS%y]<'^!V2^Sy!T0'^!V2iX3'^~AiX4^!V2^z!<8T0^8T0YU7~AiX3^'^~AiX4^iV2y!V2iX3]C*iX4^z!W07%E'_BZHYJc^BYGPc^QQEi$zQQEi$z!S:'i$8S:@`^BX$D_~F_{!;'i&(R@a_X$D_~F_{!V#i:!T.i9!S3#l`^{!TJZBl!W?8GYS'aQ_^{!V18S+YS'k^z!W+8S$b`P^|!U@8S>`P^{!WIi:]Mi9!S+#oYD_^z!S)ZBo!UK8GYS'aQ_^{!VM8MYOi&YH^z!08MYOYH`YH^{!T58Ma8T5?fZ@bb`a_Il`~Ka_}']K8T5i&b`^|!T3'k'iX4~F_'l8T3@b@`'l~K`^'iX4~K__D`D^~F_~F^{!S58T3YH`YH^{!UO5YTC`^{!WH5YTE`^{!TE4YS5a_k{!TC4kYS5`^{!T-*kYS5`^{!VJ8MYS'vC^z!V08S$b`P^|]@8S>`P^{]$i:!Hi9!M#nYD_^z]OZBn!T6i'!S#i'!WEj&!VEiTH!W'iU#!UFi4!U*i*!T4'_'i$'i$8T4IIvR%`YEbu@_~KvR/^~K_vR$D^~F^{!T=8T4k^'i$~Z4^z!TN'i$2_k~^YT=^8T=@^~AvPD^'i$~Z4^YH^z!S/'^8S/_`~Kak?b^JIYEu``vR%Z+u^{]G8MYS/i&^8M?YS/i&I`kvP~Kk^z!U6'^8E__~YU8`YU6Z+m`YE_^'l~Ak_{!VCi'!V:i'!VFi'!W#i'!V>'lz!W&i'!W:8E_Z+YU2``_YS&`YS&^'k~Ak_{!S@8S@_YTD__'_~Ak^{!U28S@`^8S@__~K__YS&`YS&^{!W63b^'^~AKkbKk`'k~Ak^IYE`a_Z+`^{!TD2YEZ+b``^{!S&'^2_k~Kk^z!V?'_'^~K`^{!W7'^'_~K`^{!U85YTK^z!TK*YEZ+m`m^z!VI4k^z!UC4_kz!UB*k^z]&5K`^{!TH5K__{!U#4__{!Ni*!U45Z(^zBZ5ki#!UHQi#!T?'^!UH?iUH^YTP^8T?Qa_'^~U`Q^P_~F_{!S=8T?iUH^z!UGiG!V.i9!T'i:!TP#m_i$z!IZBm!SJ'`8SJ?ca`Il^~K_k|!S'8SJi&`^{]I'i$9I@a_'^~UD__D_~F_{]-iTL!TL'i$8TL@a_'^~AD__D_~F_{!T7'i$8T7@`^'_~UD`^~F_{!V/iP!P'i$8P@`^'_~AD`^~F_{!SB'^8SBIl`@^~K`k{!S$8S1aYSB`^|!S>-YSB`^{!SG'_8SG?aD_@^~F^{]%8SGi&^z!O'_(YOa@_D^~F^{!D'k3YD@_l~F^z!SE94^94^8SE@a@^~F^'i$~YTOa^@^~F^{!W%8SE_^z]4*i&^z!W$8S(Q^z!W38S(P^z!W.8SFQ^z!V-8SFP^z!V+8SHQ^z!UL8SHP^z!W=8T9Q^z!WD8T9P^z!V78LP^z!W-8T2Q^z!W,8T2P^z!UA8SLQ^z!V98SLP^z!V68T&Q^z!WF8T&P^z!S(87Q^z!SF87P^z!SH8T(Q^z!T98T(P^z!T21P^z!SL8SKQ^z!T&8SKP^z!T(8:P^z!SK89P^z]D8LQ^z!L1Q^z!78:Q^z!189Q^z],j5!S1iG!)i:!-i9!(#k`^{!/ZBk!>'i$'i$'i$'i$8>PaP_~UQaQ_~UYJaYJ_~Z(`'i$~ApYJ_~Z(_'^~^A`^{!TOi*!WA5_'^~^Ai%^z!5*i$^z]B.'i$*bYJ^~Z(^zz!Y':nn:k:k:ki&vS4vS=vS9!Y0:nl:ki&vP!X%:nki&!X0:np:k:k:k:k:ki&vR#vS4vS=vS9vR$!X::np:k:k:k:k:ki&vR$vS;vS:vS6vS/!XC:nki&!XK:nv::k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS4vS(vS9vS.vS6vS9vS7vCvS,vS/vS;vCvS-vS6vCvS,vS+vS6vS*vCvRBvRKvRG!XD:nv>:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vDvRDvRAvRAvR:vR=vCvS:vS;vS5vS0vS9vS7vCvS;vS(vS/vS;vCvS,vS+vS6vS*vCvRBvRKvRG!X;:nl:ki&vO!Y%:nl:ki&vO!XL:nl:ki&vC!WO:nl:ki&vC!Y-:nvR$:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS@vR+vS=vS2vS3vR/vJvDvS4vS2vS3vR/vKvDvR2vRGvS=vR3vR4vR/vRGvS=vR3vR4vR6vRGvS=vR3vR4vR6vRGvS=vR3vR4vR9vRGvS=vR3vR4vR9vS=vR3vR4vS<vJvR0vL!X7:nn:k:k:ki&vS4vS=vS9!X,:nr:k:k:k:k:k:k:ki&vS@vS-vS0vS5vS0vS4vR$!XI:np:k:k:k:k:ki&vR$vS;vS:vS6vS/!XA:nn:k:k:ki&vS4vS=vS9!WK:nr:k:k:k:k:k:k:ki&uvS:vS,vS;vS@vS)vC!X(:nv8:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vCvR/vS/vS;vS.vS5vS,vS3vCvS,vS+vS6vS*vCvRBvRKvRGvCvMvMvM!Y#:nki&!Y):nn:k:k:ki&vS4vS=vS9!XB:nl:ki&vP!XJ:nn:k:k:ki&vS)vS0vS3!X.:no:k:k:k:ki&vS4vS*vS:vR#!X8:nki&!Y.:nl:ki&vR0!X#:nl:ki&vO!X&:nki&!Y1:nki&!Y(:nki&!XO:k:k:k:ki&w&w%w$w#!XG:nv/:k:k:k:k:k:k:k:k:k:k:k:ki&vS+vS,vS;vS*vS,vS7vS?vS,vCvS)vS0vS9!X?:nu:k:k:k:k:k:k:k:k:k:ki&vS7vS6vCvS5vS>vS6vS5vS2vS5vS<!X>:nv5:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS:vS5vS6vS*vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X5:nv3:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS,vS.vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X*:nv3:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS,vS:vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!WM:nv4:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS3vS3vS(vS*vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X':nv4:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS7vS4vS<vS1vCvS,vS+vS6vS*vS5vS,vCvS;vJvS5vS(vS*!X1:nl:ki&vS&!X6:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&:k:ki&v7wSA:k:ki&v6wF:k:ki&v5wU7:k:ki&v4x+:k:ki&v3wE:k:ki&v2w2:k:ki&v1w3:k:ki&v0w4:k:ki&v/w*:k:ki&v.xH:k:ki&ux5:k:ki&twG:k:ki&swJ:k:ki&rw::k:ki&qw9:k:ki&px(:k:ki&ow.:k:ki&nw,:k:ki&mw+:k:ki&lw':k:ki&kw#!X@:nv7:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS;vS5vS(vS;vS:vS5vS6vS*vCvS+vS3vS0vS<vS)vCvS;vJvS5vS(vS*!XH:k:k:ki&i&i%i$!XP:ki&k!Y+:nv0:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR/vS:vS;vS9vS6vS7vS?vS,vCvMvMvM!Y,:nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR/vS,vS+vS6vS*vCvRBvRKvRGvCvMvMvM!WN:nv?:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS5vS6vS0vS;vS(vS3vS0vS7vS4vS6vS*vCvS(vS3vCvS,vS+vCvS;vS<vS)vS,vS+vCvS;vS<vS6vRI!X+:nvR#:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS:vS;vS9vS6vS7vS?vS,vPvS/vS;vS0vS>vPvS:vS9vS7vS?vS,vPvS7vS4vS6vS*vCvS,vS+vCvS;vS<vS)vS,vS+vCvS<vS(vCvS+vS5vS,vS9vCvS,vS:vCvS5vRD!X-:nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS,vS3vS*vS<vS6vS)vCvS(vS3vCvS:vS5vS(vR9!WP:nvR$:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS:vS5vS0vS6vS4vCvS<vS(vCvS:vS;vS9vS6vS7vS?vS,vPvS;vS*vS(vS9vS;vS?vS,vCvS<vS+vCvS;vS<vS)vS,vS+vCvS<vS(vCvS+vS5vS,vS9vCvS,vS:vCvS5vRD!X<:ki&wWC!X2:k:k:k:ki&:ki&wUEi&wUEwW)!XM:nki&!XE:nki&!Y*:nl:ki&vR$!Y$:nm:k:ki&vR$vR#!X):nki&!WL:nn:k:k:ki&vR5vR5vR5!X/:nki&!X9:nv.:k:k:k:k:k:k:k:k:k:k:ki&uvR#vS@vS3vS3vS(vS<vS5vS(vS4vC!Y/:nvE:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vCvS.vS5vS0vS5vS5vS<vS9vCvS@vS9vS;vCvS6vS;vCvS;vS5vS(vS>vCvS;vS/vS.vS0vS4vCvS<vS6vRNvCvMvMvM!X$:nvO:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvR#vS+vS,vS0vS-vS0vS5vS0vS4vCvS;vS6vS5vCvS:vS(vS>vCvS,vS+vS6vS*vCvS+vS,vS;vS(vS9vS,vS5vS,vS.vCvS,vS/vS;vCvS6vS:vCvMvMvM!XN:nvR/:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&uvS4vS,vS;vS:vS@vS:vCvS,vS4vS,vS/vS*vRHvCvS:vS0vS/vS;vCvS/vS;vS0vS>vCvS+vS,vS;vS9vS6vS7vS7vS<vS:vCvS;vS6vS5vCvS:vS0vCvS5vS6vS0vS;vS(vS*vS0vS-vS0vS5vS0vRBvCvMvMvM!Y&:nl:ki&vC!X=:nv5:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS:vS;vS5vS,vS4vS<vS.vS9vS(vCvS@vS5vS(vS4vCvS6vS6vS;!XF:nv6:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS:vS9vS,vS;vS,vS4vS(vS9vS(vS7vCvS@vS5vS(vS4vCvS6vS6vS;!X3Imk!X4Ilk!':lkl!+:lkm!,:lkn!.:lko](:lkp!9:lkq!::lkr!J:lks!G:lkt]5:lku]H:lkv.!*:lkv/!4:lkv0!3:lkv1!2:lkv2!E:lkv3]+:lkv4!U7:lkv5!F:lkv6!SA:lkv7y" u--pos) 63)))))))))))
(define Main-getAndIncrement (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (unbox arg-1))))) (lambda (u--v) (PreludeC-45Interfaces-C-62C-62 (let ((e-7 (car arg-2))) e-7) (DataC-45IORef-modifyIORef arg-2 arg-1 (lambda (arg-0) (bs+ arg-0 1 63))) (lambda () (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) u--v))))))))))))
(define Main-error (lambda (arg-2 arg-3) (PreludeC-45Interfaces-C-62C-62 (let ((e-1 (car arg-3))) e-1) (PreludeC-45IO-putStrLn arg-3 (string-append "*** error : " arg-2)) (lambda () (System-exitFailure arg-3)))))
(define Main-decodeStackAux (lambda (arg-1 arg-2 arg-3 arg-4 arg-5 arg-6) (let ((u--d (Main-unsafeIndex (Main-ins) arg-2))) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int (bs+ u--d 2 63) arg-3))) (cond ((equal? sc0 1) (Main-decodeStackAux arg-1 (bs+ arg-2 1 63) (bs- arg-3 (bs+ u--d 3 63) 63) arg-4 arg-5 arg-6)) (else (let ((sc1 (PreludeC-45EqOrd-u--C-60_Ord_Int 90 arg-4))) (cond ((equal? sc1 1) (let ((e-1 (car arg-6))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCdr arg-5 arg-6)) (lambda (u--cdrStack) (let ((e-7 (car arg-6))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCar arg-5 arg-6)) (lambda (u--carStack) (Main-addInstruction arg-1 (vector 0 4) u--carStack u--cdrStack arg-6)))))))))) (else (let ((e-1 (car arg-6))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-2 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc3 1) (Main-rCons arg-1 (vector 0 0) arg-5 arg-6)) (else (let ((e-7 (car arg-6))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) arg-5)))))))) (lambda (u--stack) (let ((e-7 (car arg-6))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (let ((sc4 (PreludeC-45EqOrd-u--C-60_Ord_Int arg-3 u--d))) (cond ((equal? sc4 1) (let ((sc5 (PreludeC-45EqOrd-u--C-60_Ord_Int arg-2 (blodwen-toSignedInt 3 63)))) (cond ((equal? sc5 1) (Main-sym arg-1 arg-3 arg-6)) (else (let ((e-12 (car arg-6))) (let ((e-15 (vector-ref e-12 0))) (let ((e-17 (vector-ref e-15 1))) ((e-17 'erased) (vector 0 arg-3))))))))) (else (let ((sc5 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-3 u--d))) (cond ((equal? sc5 1) (let ((e-12 (car arg-6))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-getInt (let ((e-18 (vector-ref arg-1 3))) e-18) arg-6 0)) (lambda (u--v) (let ((e-17 (car arg-6))) (let ((e-20 (vector-ref e-17 0))) (let ((e-22 (vector-ref e-20 1))) ((e-22 'erased) (vector 0 u--v)))))))))) (else (let ((e-12 (car arg-6))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-getInt (let ((e-18 (vector-ref arg-1 3))) e-18) arg-6 (bs- (bs- arg-3 u--d 63) 1 63))) (lambda (u--v) (Main-sym arg-1 u--v arg-6)))))))))))) (lambda (u--opnd) (let ((sc4 (PreludeC-45EqOrd-u--C-60_Ord_Int 4 arg-2))) (cond ((equal? sc4 1) (let ((e-12 (car arg-6))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCar u--stack arg-6)) (lambda (u--scar) (let ((e-17 (car arg-6))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-MakeRib (let ((e-22 (vector-ref arg-1 4))) e-22) u--opnd (vector 0 0) u--scar arg-6)) (lambda (u--inter) (let ((e-22 (car arg-6))) (let ((e-24 (vector-ref e-22 1))) ((((e-24 'erased) 'erased) (Main-MakeRib (let ((e-27 (vector-ref arg-1 4))) e-27) u--inter (let ((e-29 (vector-ref arg-1 2))) e-29) (vector 0 1) arg-6)) (lambda (u--proc) (let ((e-27 (car arg-6))) (let ((e-29 (vector-ref e-27 1))) ((((e-29 'erased) 'erased) (Main-rCdr u--stack arg-6)) (lambda (stack-0) (let ((sc9 (Main-rIsRib stack-0))) (cond ((equal? sc9 1) (Main-addInstruction arg-1 (vector 0 3) u--proc stack-0 arg-6)) (else (let ((e-32 (car arg-6))) (let ((e-35 (vector-ref e-32 0))) (let ((e-37 (vector-ref e-35 1))) ((e-37 'erased) u--proc)))))))))))))))))))))))) (else (Main-addInstruction arg-1 (let ((sc5 (PreludeC-45EqOrd-u--C-60_Ord_Int 0 arg-2))) (cond ((equal? sc5 1) (vector 0 (bs- arg-2 1 63))) (else (vector 0 0)))) u--opnd u--stack arg-6)))))))))))))))))))))
(define Main-decodeStack (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getByte (let ((e-8 (vector-ref arg-1 3))) e-8) arg-3)) (lambda (u--x) (let ((x-0 (Main-getCode u--x))) (Main-decodeStackAux arg-1 0 x-0 x-0 arg-2 arg-3))))))))
(define Main-decodeAndRun (lambda (ext-0) (let ((act-24 ((csegen-39) ext-0))) (let ((act-25 (lambda (eta-0) (lambda (eta-1) (lambda (eta-2) (lambda (eta-3) (Main-MakeRib act-24 eta-0 eta-1 eta-2 eta-3))))))) (let ((act-26 (((((act-25 (vector 0 0)) (vector 0 0)) (vector 0 5)) (csegen-38)) ext-0))) (let ((act-27 (((((act-25 (vector 0 0)) (vector 0 0)) (vector 0 5)) (csegen-38)) ext-0))) (let ((act-28 (((((act-25 (vector 0 0)) (vector 0 0)) (vector 0 5)) (csegen-38)) ext-0))) (let ((act-29 ((csegen-39) ext-0))) (let ((u--state (vector act-26 act-27 act-28 act-29 act-24 act-28))) (let ((act-30 ((Main-getInt act-29 (csegen-38) 0) ext-0))) (let ((act-31 ((Main-buildSymtbl u--state act-30 (let ((e-5 (vector-ref u--state 5))) e-5) (csegen-38)) ext-0))) (let ((act-32 (vector (let ((e-0 (vector-ref u--state 0))) e-0) (let ((e-1 (vector-ref u--state 1))) e-1) (let ((e-2 (vector-ref u--state 2))) e-2) (let ((e-3 (vector-ref u--state 3))) e-3) (let ((e-4 (vector-ref u--state 4))) e-4) act-31))) (let ((act-33 ((Main-decodeStack act-32 (vector 0 0) (csegen-38)) ext-0))) (let ((act-34 ((Main-setupGlobal act-32 (csegen-38)) ext-0))) (let ((act-35 ((Main-rCar act-33 (csegen-38)) ext-0))) (let ((act-36 ((Main-rCgr act-35 (csegen-38)) ext-0))) (let ((act-37 (((((act-25 (vector 0 5)) (vector 0 0)) (vector 0 0)) (csegen-38)) ext-0))) (let ((act-38 (((((act-25 (vector 0 0)) (vector 0 0)) act-37) (csegen-38)) ext-0))) ((Main-run act-32 act-36 act-38 0 (csegen-38)) ext-0)))))))))))))))))))
(define Main-close (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-2 arg-3)) (lambda (u--x) (let ((e-7 (car arg-3))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCdr arg-2 arg-3)) (lambda (u--stack) (let ((e-12 (car arg-3))) (let ((e-14 (vector-ref e-12 1))) ((((e-14 'erased) 'erased) (Main-rCar u--x arg-3)) (lambda (u--xCar) (let ((e-17 (car arg-3))) (let ((e-19 (vector-ref e-17 1))) ((((e-19 'erased) 'erased) (Main-MakeRib (let ((e-22 (vector-ref arg-1 4))) e-22) u--xCar u--stack (vector 0 1) arg-3)) (lambda (u--newRib) (Main-rCons arg-1 u--newRib u--stack arg-3)))))))))))))))))))
(define Main-buildSymtbl (lambda (arg-1 arg-2 arg-3 arg-4) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int 0 arg-2))) (cond ((equal? sc0 1) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-addSymbol arg-1 (let ((e-9 (vector-ref arg-1 2))) e-9) arg-3 arg-4)) (lambda (u--sym) (Main-buildSymtbl arg-1 (bs- arg-2 1 63) u--sym arg-4)))))) (else (Main-buildChar arg-1 (let ((e-2 (vector-ref arg-1 2))) e-2) arg-3 arg-4))))))
(define Main-buildChar (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getByte (let ((e-8 (vector-ref arg-1 3))) e-8) arg-4)) (lambda (u--x) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--x (blodwen-toSignedInt 44 63)))) (cond ((equal? sc1 1) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-addSymbol arg-1 arg-2 arg-3 arg-4)) (lambda (u--sym) (Main-buildChar arg-1 (let ((e-14 (vector-ref arg-1 2))) e-14) u--sym arg-4)))))) (else (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int u--x (blodwen-toSignedInt 59 63)))) (cond ((equal? sc2 1) (Main-addSymbol arg-1 arg-2 arg-3 arg-4)) (else (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rCons arg-1 (vector 0 u--x) arg-2 arg-4)) (lambda (u--r) (Main-buildChar arg-1 u--r arg-3 arg-4)))))))))))))))))
(define Main-arg2 (lambda (arg-1 arg-2 arg-3) (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) arg-2))))))
(define Main-addSymbol (lambda (arg-1 arg-2 arg-3 arg-4) (let ((e-1 (car arg-4))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rListToString arg-1 arg-2 arg-4)) (lambda (u--lst) (let ((e-7 (car arg-4))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-rStringToUninternedSymbol arg-1 u--lst arg-4)) (lambda (u--sym) (Main-rCons arg-1 u--sym arg-3 arg-4)))))))))))
(define Main-addInstruction (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-1 (car arg-5))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-rCar arg-4 arg-5)) (lambda (u--oscar) (let ((e-7 (car arg-5))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (Main-MakeRib (let ((e-12 (vector-ref arg-1 4))) e-12) arg-2 arg-3 u--oscar arg-5)) (lambda (u--newRib) (PreludeC-45Interfaces-C-62C-62 (let ((e-12 (car arg-5))) e-12) (Main-setCar arg-4 u--newRib arg-5) (lambda () (Main-decodeStack arg-1 arg-4 arg-5)))))))))))))
(define Main-MakeRib (lambda (arg-1 arg-2 arg-3 arg-4 arg-5) (let ((e-1 (car arg-5))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (Main-getAndIncrement arg-1 arg-5)) (lambda (u--v) (let ((e-7 (car arg-5))) (let ((e-9 (vector-ref e-7 1))) ((((e-9 'erased) 'erased) (DataC-45IORef-newIORef arg-5 (vector u--v arg-2 arg-3 arg-4))) (lambda (u--ref) (let ((e-12 (car arg-5))) (let ((e-15 (vector-ref e-12 0))) (let ((e-17 (vector-ref e-15 1))) ((e-17 'erased) (vector 1 u--ref)))))))))))))))
(define Main-C-61C-61 (lambda (arg-1 arg-2 arg-3) (case (vector-ref arg-1 0) ((0) (let ((e-0 (vector-ref arg-1 1))) (case (vector-ref arg-2 0) ((0) (let ((e-2 (vector-ref arg-2 1))) (let ((e-1 (car arg-3))) (let ((e-6 (vector-ref e-1 0))) (let ((e-8 (vector-ref e-6 1))) ((e-8 'erased) (PreludeC-45EqOrd-u--C-61C-61_Eq_Int e-0 e-2)))))))(else (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) 0)))))))) ((1) (let ((e-1 (vector-ref arg-1 1))) (case (vector-ref arg-2 0) ((1) (let ((e-3 (vector-ref arg-2 1))) (let ((e-4 (car arg-3))) (let ((e-6 (vector-ref e-4 1))) ((((e-6 'erased) 'erased) (let ((e-8 (cdr arg-3))) ((e-8 'erased) (lambda (eta-0) (unbox e-1))))) (lambda (u--rib1) (let ((e-9 (car arg-3))) (let ((e-11 (vector-ref e-9 1))) ((((e-11 'erased) 'erased) (let ((e-13 (cdr arg-3))) ((e-13 'erased) (lambda (eta-0) (unbox e-3))))) (lambda (u--rib2) (let ((e-14 (car arg-3))) (let ((e-17 (vector-ref e-14 0))) (let ((e-19 (vector-ref e-17 1))) ((e-19 'erased) (PreludeC-45EqOrd-u--C-61C-61_Eq_Int (let ((e-0 (vector-ref u--rib1 0))) e-0) (let ((e-0 (vector-ref u--rib2 0))) e-0))))))))))))))))(else (let ((e-3 (car arg-3))) (let ((e-6 (vector-ref e-3 0))) (let ((e-8 (vector-ref e-6 1))) ((e-8 'erased) 0))))))))(else (let ((e-1 (car arg-3))) (let ((e-5 (vector-ref e-1 0))) (let ((e-7 (vector-ref e-5 1))) ((e-7 'erased) 0))))))))
(define System-exitWith (lambda (arg-2 arg-3) (if (null? arg-3) (let ((e-2 (cdr arg-2))) ((e-2 'erased) (Builtin-believe_me (lambda (eta-0) (System-prim__exit 0 eta-0))))) (let ((e-0 (car arg-3))) (let ((e-2 (cdr arg-2))) ((e-2 'erased) (Builtin-believe_me (lambda (eta-0) (System-prim__exit e-0 eta-0)))))))))
(define System-exitFailure (lambda (arg-2) (System-exitWith arg-2 (cons 1 (vector 0 )))))
(define Builtin-idris_crash (lambda (ext-0) (blodwen-error-quit (string-append "ERROR: " ext-0))))
(define Builtin-believe_me (lambda (ext-0) ext-0))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (let ((sc1 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc1 0) 0)(else 1))))) (cond ((equal? sc0 1) (Builtin-believe_me arg-0)) (else 0)))))
(define PreludeC-45Num-u--div_Integral_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-1 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 0) (bs/ arg-0 arg-1 63))(else (Builtin-idris_crash "Unhandled input for Prelude.Num.case block in div at Prelude.Num:120:3--122:40"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-60_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Interfaces-C-62C-62 (lambda (arg-2 arg-3 arg-4) (let ((e-2 (vector-ref arg-2 1))) ((((e-2 'erased) 'erased) arg-3) (lambda (_-1843) (arg-4))))))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (arg-1 u--w)))))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-5 (arg-3 ext-0))) (arg-2 act-5))))
(define PreludeC-45IO-putStrLn (lambda (arg-1 arg-2) (PreludeC-45IO-putStr arg-1 (string-append arg-2 "\xa;"))))
(define PreludeC-45IO-putStr (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (PreludeC-45IO-prim__putStr arg-2 eta-0))))))
(define PreludeC-45IO-putChar (lambda (arg-1 arg-2) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (PreludeC-45IO-prim__putChar arg-2 eta-0))))))
(define PreludeC-45IO-getChar (lambda (arg-1) (let ((e-2 (cdr arg-1))) ((e-2 'erased) (lambda (eta-0) (PreludeC-45IO-prim__getChar eta-0))))))
(define DataC-45IORef-newIORef (lambda (arg-2 arg-3) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (box arg-3))))) (lambda (u--m) (let ((e-7 (car arg-2))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) u--m))))))))))
(define DataC-45IORef-modifyIORef (lambda (arg-2 arg-3 arg-4) (let ((e-1 (car arg-2))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (unbox arg-3))))) (lambda (u--val) (let ((e-6 (cdr arg-2))) ((e-6 'erased) (lambda (eta-0) (set-box! arg-3 (arg-4 u--val)))))))))))
(load-shared-object "libidris2_support.so")
(collect-request-handler (lambda () (collect) (blodwen-run-finalisers)))
(PrimIO-unsafePerformIO (lambda (eta-0) (Main-main eta-0)))  (collect 4)
  (blodwen-run-finalisers)
  
  )